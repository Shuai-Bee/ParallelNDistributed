Parallel for 4 types schedule


for (int iter = 0; iter < maxIter; iter++) {
    if (typeName == "Static") {
    #pragma omp parallel for schedule(static)
        for (int i = 0; i < n; i++) {
            double sigma = 0.0;
            for (int j = 0; j < n; j++) {
                if (i != j) sigma += A[i][j] * x[j];
            }
            x_new[i] = (b[i] - sigma) / A[i][i];
        }
    }
    else if (typeName == "Dynamic") {
    #pragma omp parallel for schedule(dynamic)
        for (int i = 0; i < n; i++) {
            double sigma = 0.0;
            for (int j = 0; j < n; j++) {
                if (i != j) sigma += A[i][j] * x[j];
            }
            x_new[i] = (b[i] - sigma) / A[i][i];
        }
    }
    else if (typeName == "Guided") {
    #pragma omp parallel for schedule(guided)
        for (int i = 0; i < n; i++) {
            double sigma = 0.0;
            for (int j = 0; j < n; j++) {
                if (i != j) sigma += A[i][j] * x[j];
            }
            x_new[i] = (b[i] - sigma) / A[i][i];
        }
    }
    else {
    #pragma omp parallel for schedule(auto)
        for (int i = 0; i < n; i++) {
            double sigma = 0.0;
            for (int j = 0; j < n; j++) {
                if (i != j) sigma += A[i][j] * x[j];
            }
            x_new[i] = (b[i] - sigma) / A[i][i];
        }
    }

    // Parallel reduction to compute total error
    double error = 0.0;
    #pragma omp parallel for reduction(+:error)
    for (int i = 0; i < n; i++)
        error += fabs(x_new[i] - x[i]);

    // Stop if converged
    if (error < tol)
        break;

    // Update solution vector
    x = x_new;
}
